// @generated by protobuf-ts 2.10.0
// @generated from protobuf file "headscale/v1/device.proto" (package "headscale.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../google/protobuf/timestamp";
// This is a potential reimplementation of Tailscale's API
// https://github.com/tailscale/tailscale/blob/main/api.md

/**
 * @generated from protobuf message headscale.v1.Latency
 */
export interface Latency {
    /**
     * @generated from protobuf field: float latency_ms = 1;
     */
    latencyMs: number;
    /**
     * @generated from protobuf field: bool preferred = 2;
     */
    preferred: boolean;
}
/**
 * @generated from protobuf message headscale.v1.ClientSupports
 */
export interface ClientSupports {
    /**
     * @generated from protobuf field: bool hair_pinning = 1;
     */
    hairPinning: boolean;
    /**
     * @generated from protobuf field: bool ipv6 = 2;
     */
    ipv6: boolean;
    /**
     * @generated from protobuf field: bool pcp = 3;
     */
    pcp: boolean;
    /**
     * @generated from protobuf field: bool pmp = 4;
     */
    pmp: boolean;
    /**
     * @generated from protobuf field: bool udp = 5;
     */
    udp: boolean;
    /**
     * @generated from protobuf field: bool upnp = 6;
     */
    upnp: boolean;
}
/**
 * @generated from protobuf message headscale.v1.ClientConnectivity
 */
export interface ClientConnectivity {
    /**
     * @generated from protobuf field: repeated string endpoints = 1;
     */
    endpoints: string[];
    /**
     * @generated from protobuf field: string derp = 2;
     */
    derp: string;
    /**
     * @generated from protobuf field: bool mapping_varies_by_dest_ip = 3;
     */
    mappingVariesByDestIp: boolean;
    /**
     * @generated from protobuf field: map<string, headscale.v1.Latency> latency = 4;
     */
    latency: {
        [key: string]: Latency;
    };
    /**
     * @generated from protobuf field: headscale.v1.ClientSupports client_supports = 5;
     */
    clientSupports?: ClientSupports;
}
/**
 * @generated from protobuf message headscale.v1.GetDeviceRequest
 */
export interface GetDeviceRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
}
/**
 * @generated from protobuf message headscale.v1.GetDeviceResponse
 */
export interface GetDeviceResponse {
    /**
     * @generated from protobuf field: repeated string addresses = 1;
     */
    addresses: string[];
    /**
     * @generated from protobuf field: string id = 2;
     */
    id: string;
    /**
     * @generated from protobuf field: string user = 3;
     */
    user: string;
    /**
     * @generated from protobuf field: string name = 4;
     */
    name: string;
    /**
     * @generated from protobuf field: string hostname = 5;
     */
    hostname: string;
    /**
     * @generated from protobuf field: string client_version = 6;
     */
    clientVersion: string;
    /**
     * @generated from protobuf field: bool update_available = 7;
     */
    updateAvailable: boolean;
    /**
     * @generated from protobuf field: string os = 8;
     */
    os: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created = 9;
     */
    created?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp last_seen = 10;
     */
    lastSeen?: Timestamp;
    /**
     * @generated from protobuf field: bool key_expiry_disabled = 11;
     */
    keyExpiryDisabled: boolean;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp expires = 12;
     */
    expires?: Timestamp;
    /**
     * @generated from protobuf field: bool authorized = 13;
     */
    authorized: boolean;
    /**
     * @generated from protobuf field: bool is_external = 14;
     */
    isExternal: boolean;
    /**
     * @generated from protobuf field: string machine_key = 15;
     */
    machineKey: string;
    /**
     * @generated from protobuf field: string node_key = 16;
     */
    nodeKey: string;
    /**
     * @generated from protobuf field: bool blocks_incoming_connections = 17;
     */
    blocksIncomingConnections: boolean;
    /**
     * @generated from protobuf field: repeated string enabled_routes = 18;
     */
    enabledRoutes: string[];
    /**
     * @generated from protobuf field: repeated string advertised_routes = 19;
     */
    advertisedRoutes: string[];
    /**
     * @generated from protobuf field: headscale.v1.ClientConnectivity client_connectivity = 20;
     */
    clientConnectivity?: ClientConnectivity;
}
/**
 * @generated from protobuf message headscale.v1.DeleteDeviceRequest
 */
export interface DeleteDeviceRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
}
/**
 * @generated from protobuf message headscale.v1.DeleteDeviceResponse
 */
export interface DeleteDeviceResponse {
}
/**
 * @generated from protobuf message headscale.v1.GetDeviceRoutesRequest
 */
export interface GetDeviceRoutesRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
}
/**
 * @generated from protobuf message headscale.v1.GetDeviceRoutesResponse
 */
export interface GetDeviceRoutesResponse {
    /**
     * @generated from protobuf field: repeated string enabled_routes = 1;
     */
    enabledRoutes: string[];
    /**
     * @generated from protobuf field: repeated string advertised_routes = 2;
     */
    advertisedRoutes: string[];
}
/**
 * @generated from protobuf message headscale.v1.EnableDeviceRoutesRequest
 */
export interface EnableDeviceRoutesRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: repeated string routes = 2;
     */
    routes: string[];
}
/**
 * @generated from protobuf message headscale.v1.EnableDeviceRoutesResponse
 */
export interface EnableDeviceRoutesResponse {
    /**
     * @generated from protobuf field: repeated string enabled_routes = 1;
     */
    enabledRoutes: string[];
    /**
     * @generated from protobuf field: repeated string advertised_routes = 2;
     */
    advertisedRoutes: string[];
}
// @generated message type with reflection information, may provide speed optimized methods
class Latency$Type extends MessageType<Latency> {
    constructor() {
        super("headscale.v1.Latency", [
            { no: 1, name: "latency_ms", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "preferred", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Latency>): Latency {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.latencyMs = 0;
        message.preferred = false;
        if (value !== undefined)
            reflectionMergePartial<Latency>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Latency): Latency {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float latency_ms */ 1:
                    message.latencyMs = reader.float();
                    break;
                case /* bool preferred */ 2:
                    message.preferred = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Latency, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float latency_ms = 1; */
        if (message.latencyMs !== 0)
            writer.tag(1, WireType.Bit32).float(message.latencyMs);
        /* bool preferred = 2; */
        if (message.preferred !== false)
            writer.tag(2, WireType.Varint).bool(message.preferred);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message headscale.v1.Latency
 */
export const Latency = new Latency$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientSupports$Type extends MessageType<ClientSupports> {
    constructor() {
        super("headscale.v1.ClientSupports", [
            { no: 1, name: "hair_pinning", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "ipv6", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "pcp", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "pmp", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "udp", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "upnp", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ClientSupports>): ClientSupports {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hairPinning = false;
        message.ipv6 = false;
        message.pcp = false;
        message.pmp = false;
        message.udp = false;
        message.upnp = false;
        if (value !== undefined)
            reflectionMergePartial<ClientSupports>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientSupports): ClientSupports {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool hair_pinning */ 1:
                    message.hairPinning = reader.bool();
                    break;
                case /* bool ipv6 */ 2:
                    message.ipv6 = reader.bool();
                    break;
                case /* bool pcp */ 3:
                    message.pcp = reader.bool();
                    break;
                case /* bool pmp */ 4:
                    message.pmp = reader.bool();
                    break;
                case /* bool udp */ 5:
                    message.udp = reader.bool();
                    break;
                case /* bool upnp */ 6:
                    message.upnp = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientSupports, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool hair_pinning = 1; */
        if (message.hairPinning !== false)
            writer.tag(1, WireType.Varint).bool(message.hairPinning);
        /* bool ipv6 = 2; */
        if (message.ipv6 !== false)
            writer.tag(2, WireType.Varint).bool(message.ipv6);
        /* bool pcp = 3; */
        if (message.pcp !== false)
            writer.tag(3, WireType.Varint).bool(message.pcp);
        /* bool pmp = 4; */
        if (message.pmp !== false)
            writer.tag(4, WireType.Varint).bool(message.pmp);
        /* bool udp = 5; */
        if (message.udp !== false)
            writer.tag(5, WireType.Varint).bool(message.udp);
        /* bool upnp = 6; */
        if (message.upnp !== false)
            writer.tag(6, WireType.Varint).bool(message.upnp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message headscale.v1.ClientSupports
 */
export const ClientSupports = new ClientSupports$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientConnectivity$Type extends MessageType<ClientConnectivity> {
    constructor() {
        super("headscale.v1.ClientConnectivity", [
            { no: 1, name: "endpoints", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "derp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "mapping_varies_by_dest_ip", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "latency", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Latency } },
            { no: 5, name: "client_supports", kind: "message", T: () => ClientSupports }
        ]);
    }
    create(value?: PartialMessage<ClientConnectivity>): ClientConnectivity {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.endpoints = [];
        message.derp = "";
        message.mappingVariesByDestIp = false;
        message.latency = {};
        if (value !== undefined)
            reflectionMergePartial<ClientConnectivity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientConnectivity): ClientConnectivity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string endpoints */ 1:
                    message.endpoints.push(reader.string());
                    break;
                case /* string derp */ 2:
                    message.derp = reader.string();
                    break;
                case /* bool mapping_varies_by_dest_ip */ 3:
                    message.mappingVariesByDestIp = reader.bool();
                    break;
                case /* map<string, headscale.v1.Latency> latency */ 4:
                    this.binaryReadMap4(message.latency, reader, options);
                    break;
                case /* headscale.v1.ClientSupports client_supports */ 5:
                    message.clientSupports = ClientSupports.internalBinaryRead(reader, reader.uint32(), options, message.clientSupports);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: ClientConnectivity["latency"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ClientConnectivity["latency"] | undefined, val: ClientConnectivity["latency"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Latency.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field headscale.v1.ClientConnectivity.latency");
            }
        }
        map[key ?? ""] = val ?? Latency.create();
    }
    internalBinaryWrite(message: ClientConnectivity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string endpoints = 1; */
        for (let i = 0; i < message.endpoints.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.endpoints[i]);
        /* string derp = 2; */
        if (message.derp !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.derp);
        /* bool mapping_varies_by_dest_ip = 3; */
        if (message.mappingVariesByDestIp !== false)
            writer.tag(3, WireType.Varint).bool(message.mappingVariesByDestIp);
        /* map<string, headscale.v1.Latency> latency = 4; */
        for (let k of globalThis.Object.keys(message.latency)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Latency.internalBinaryWrite(message.latency[k], writer, options);
            writer.join().join();
        }
        /* headscale.v1.ClientSupports client_supports = 5; */
        if (message.clientSupports)
            ClientSupports.internalBinaryWrite(message.clientSupports, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message headscale.v1.ClientConnectivity
 */
export const ClientConnectivity = new ClientConnectivity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDeviceRequest$Type extends MessageType<GetDeviceRequest> {
    constructor() {
        super("headscale.v1.GetDeviceRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDeviceRequest>): GetDeviceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<GetDeviceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDeviceRequest): GetDeviceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDeviceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message headscale.v1.GetDeviceRequest
 */
export const GetDeviceRequest = new GetDeviceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDeviceResponse$Type extends MessageType<GetDeviceResponse> {
    constructor() {
        super("headscale.v1.GetDeviceResponse", [
            { no: 1, name: "addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "user", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "client_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "update_available", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "os", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "created", kind: "message", T: () => Timestamp },
            { no: 10, name: "last_seen", kind: "message", T: () => Timestamp },
            { no: 11, name: "key_expiry_disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "expires", kind: "message", T: () => Timestamp },
            { no: 13, name: "authorized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "is_external", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "machine_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "node_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "blocks_incoming_connections", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "enabled_routes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "advertised_routes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "client_connectivity", kind: "message", T: () => ClientConnectivity }
        ]);
    }
    create(value?: PartialMessage<GetDeviceResponse>): GetDeviceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.addresses = [];
        message.id = "";
        message.user = "";
        message.name = "";
        message.hostname = "";
        message.clientVersion = "";
        message.updateAvailable = false;
        message.os = "";
        message.keyExpiryDisabled = false;
        message.authorized = false;
        message.isExternal = false;
        message.machineKey = "";
        message.nodeKey = "";
        message.blocksIncomingConnections = false;
        message.enabledRoutes = [];
        message.advertisedRoutes = [];
        if (value !== undefined)
            reflectionMergePartial<GetDeviceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDeviceResponse): GetDeviceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string addresses */ 1:
                    message.addresses.push(reader.string());
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* string user */ 3:
                    message.user = reader.string();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                case /* string hostname */ 5:
                    message.hostname = reader.string();
                    break;
                case /* string client_version */ 6:
                    message.clientVersion = reader.string();
                    break;
                case /* bool update_available */ 7:
                    message.updateAvailable = reader.bool();
                    break;
                case /* string os */ 8:
                    message.os = reader.string();
                    break;
                case /* google.protobuf.Timestamp created */ 9:
                    message.created = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.created);
                    break;
                case /* google.protobuf.Timestamp last_seen */ 10:
                    message.lastSeen = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastSeen);
                    break;
                case /* bool key_expiry_disabled */ 11:
                    message.keyExpiryDisabled = reader.bool();
                    break;
                case /* google.protobuf.Timestamp expires */ 12:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                case /* bool authorized */ 13:
                    message.authorized = reader.bool();
                    break;
                case /* bool is_external */ 14:
                    message.isExternal = reader.bool();
                    break;
                case /* string machine_key */ 15:
                    message.machineKey = reader.string();
                    break;
                case /* string node_key */ 16:
                    message.nodeKey = reader.string();
                    break;
                case /* bool blocks_incoming_connections */ 17:
                    message.blocksIncomingConnections = reader.bool();
                    break;
                case /* repeated string enabled_routes */ 18:
                    message.enabledRoutes.push(reader.string());
                    break;
                case /* repeated string advertised_routes */ 19:
                    message.advertisedRoutes.push(reader.string());
                    break;
                case /* headscale.v1.ClientConnectivity client_connectivity */ 20:
                    message.clientConnectivity = ClientConnectivity.internalBinaryRead(reader, reader.uint32(), options, message.clientConnectivity);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDeviceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string addresses = 1; */
        for (let i = 0; i < message.addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.addresses[i]);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* string user = 3; */
        if (message.user !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.user);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        /* string hostname = 5; */
        if (message.hostname !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.hostname);
        /* string client_version = 6; */
        if (message.clientVersion !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.clientVersion);
        /* bool update_available = 7; */
        if (message.updateAvailable !== false)
            writer.tag(7, WireType.Varint).bool(message.updateAvailable);
        /* string os = 8; */
        if (message.os !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.os);
        /* google.protobuf.Timestamp created = 9; */
        if (message.created)
            Timestamp.internalBinaryWrite(message.created, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_seen = 10; */
        if (message.lastSeen)
            Timestamp.internalBinaryWrite(message.lastSeen, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* bool key_expiry_disabled = 11; */
        if (message.keyExpiryDisabled !== false)
            writer.tag(11, WireType.Varint).bool(message.keyExpiryDisabled);
        /* google.protobuf.Timestamp expires = 12; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* bool authorized = 13; */
        if (message.authorized !== false)
            writer.tag(13, WireType.Varint).bool(message.authorized);
        /* bool is_external = 14; */
        if (message.isExternal !== false)
            writer.tag(14, WireType.Varint).bool(message.isExternal);
        /* string machine_key = 15; */
        if (message.machineKey !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.machineKey);
        /* string node_key = 16; */
        if (message.nodeKey !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.nodeKey);
        /* bool blocks_incoming_connections = 17; */
        if (message.blocksIncomingConnections !== false)
            writer.tag(17, WireType.Varint).bool(message.blocksIncomingConnections);
        /* repeated string enabled_routes = 18; */
        for (let i = 0; i < message.enabledRoutes.length; i++)
            writer.tag(18, WireType.LengthDelimited).string(message.enabledRoutes[i]);
        /* repeated string advertised_routes = 19; */
        for (let i = 0; i < message.advertisedRoutes.length; i++)
            writer.tag(19, WireType.LengthDelimited).string(message.advertisedRoutes[i]);
        /* headscale.v1.ClientConnectivity client_connectivity = 20; */
        if (message.clientConnectivity)
            ClientConnectivity.internalBinaryWrite(message.clientConnectivity, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message headscale.v1.GetDeviceResponse
 */
export const GetDeviceResponse = new GetDeviceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteDeviceRequest$Type extends MessageType<DeleteDeviceRequest> {
    constructor() {
        super("headscale.v1.DeleteDeviceRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteDeviceRequest>): DeleteDeviceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteDeviceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteDeviceRequest): DeleteDeviceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteDeviceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message headscale.v1.DeleteDeviceRequest
 */
export const DeleteDeviceRequest = new DeleteDeviceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteDeviceResponse$Type extends MessageType<DeleteDeviceResponse> {
    constructor() {
        super("headscale.v1.DeleteDeviceResponse", []);
    }
    create(value?: PartialMessage<DeleteDeviceResponse>): DeleteDeviceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteDeviceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteDeviceResponse): DeleteDeviceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteDeviceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message headscale.v1.DeleteDeviceResponse
 */
export const DeleteDeviceResponse = new DeleteDeviceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDeviceRoutesRequest$Type extends MessageType<GetDeviceRoutesRequest> {
    constructor() {
        super("headscale.v1.GetDeviceRoutesRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDeviceRoutesRequest>): GetDeviceRoutesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<GetDeviceRoutesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDeviceRoutesRequest): GetDeviceRoutesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDeviceRoutesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message headscale.v1.GetDeviceRoutesRequest
 */
export const GetDeviceRoutesRequest = new GetDeviceRoutesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDeviceRoutesResponse$Type extends MessageType<GetDeviceRoutesResponse> {
    constructor() {
        super("headscale.v1.GetDeviceRoutesResponse", [
            { no: 1, name: "enabled_routes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "advertised_routes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDeviceRoutesResponse>): GetDeviceRoutesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enabledRoutes = [];
        message.advertisedRoutes = [];
        if (value !== undefined)
            reflectionMergePartial<GetDeviceRoutesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDeviceRoutesResponse): GetDeviceRoutesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string enabled_routes */ 1:
                    message.enabledRoutes.push(reader.string());
                    break;
                case /* repeated string advertised_routes */ 2:
                    message.advertisedRoutes.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDeviceRoutesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string enabled_routes = 1; */
        for (let i = 0; i < message.enabledRoutes.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.enabledRoutes[i]);
        /* repeated string advertised_routes = 2; */
        for (let i = 0; i < message.advertisedRoutes.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.advertisedRoutes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message headscale.v1.GetDeviceRoutesResponse
 */
export const GetDeviceRoutesResponse = new GetDeviceRoutesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnableDeviceRoutesRequest$Type extends MessageType<EnableDeviceRoutesRequest> {
    constructor() {
        super("headscale.v1.EnableDeviceRoutesRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "routes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EnableDeviceRoutesRequest>): EnableDeviceRoutesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.routes = [];
        if (value !== undefined)
            reflectionMergePartial<EnableDeviceRoutesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnableDeviceRoutesRequest): EnableDeviceRoutesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* repeated string routes */ 2:
                    message.routes.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnableDeviceRoutesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* repeated string routes = 2; */
        for (let i = 0; i < message.routes.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.routes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message headscale.v1.EnableDeviceRoutesRequest
 */
export const EnableDeviceRoutesRequest = new EnableDeviceRoutesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnableDeviceRoutesResponse$Type extends MessageType<EnableDeviceRoutesResponse> {
    constructor() {
        super("headscale.v1.EnableDeviceRoutesResponse", [
            { no: 1, name: "enabled_routes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "advertised_routes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EnableDeviceRoutesResponse>): EnableDeviceRoutesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enabledRoutes = [];
        message.advertisedRoutes = [];
        if (value !== undefined)
            reflectionMergePartial<EnableDeviceRoutesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnableDeviceRoutesResponse): EnableDeviceRoutesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string enabled_routes */ 1:
                    message.enabledRoutes.push(reader.string());
                    break;
                case /* repeated string advertised_routes */ 2:
                    message.advertisedRoutes.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnableDeviceRoutesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string enabled_routes = 1; */
        for (let i = 0; i < message.enabledRoutes.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.enabledRoutes[i]);
        /* repeated string advertised_routes = 2; */
        for (let i = 0; i < message.advertisedRoutes.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.advertisedRoutes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message headscale.v1.EnableDeviceRoutesResponse
 */
export const EnableDeviceRoutesResponse = new EnableDeviceRoutesResponse$Type();
